---
title: "Predicting Urban Growth"
author: "Austin, TX"
date: "Olivia Scalora & Hasa Reddy"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    code_download: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

<style>
  .superbigimage{
      overflow-x:scroll;
      white-space: nowrap;
  }

  .superbigimage img{
     max-width: none;
  }

</style>

# Introduction


This is a report to predict 2029 urban growth rate and patterns of Austin, TX.

With the current upward rapid rise population and economic development rate, it is at most important to predict population increase in order to efficiently beforehand work towards planning allocation of resources, budgets and infrastructure.These predictions come very handy not only to planners, but also to residents, industries, economics locally but also outside of the region, above all a sustainable urban development. These predictions not only help in planning urban growth abut also in prevention of urban growth.Urban growth is a spatial process which has a significant impact on the earthâ€™s environment, which need to be tracked and predicted to not lead to urban sprawl into environmentally sensitive areas;  forests, wetlands, farmlands etc.

According to  Official Website of The City of Austin,TX is said be Forbes list of America's fasting growing cities, the third best city for good jobs, Third-fastest-growing tech job market along with being the most connected city, making it unquestionably attract people around the country, steady leading to rise in population growth. We are choosing this city as its already has seen a substantial growth but also will surely be a city that need to be explored as a priority given its current growth rates.

```{r load_packages, message=FALSE, warning=FALSE, results = "hide"}
# install.packages("RCurl")
library(tidyverse)
library(sf)
library(raster)
library(knitr)
library(kableExtra)
library(tidycensus)
library(tigris)
library(FNN)
#library(QuantPsyc) # JE Note: in R 4.1, QuantPsyc package not available.
library(caret)
library(yardstick)
library(pscl)
library(plotROC) 
library(ggrepel)
library(pROC)
library(grid)
library(gridExtra)
library(viridis)
library(igraph)
library(RCurl)

options(scipen = 100)

plotTheme <- theme(
  plot.title =element_text(size=12),
  plot.subtitle = element_text(size=8),
  plot.caption = element_text(size = 6),
  axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
  axis.text.y = element_text(size = 10),
  axis.title.y = element_text(size = 10),
  # Set the entire chart region to blank
  panel.background=element_blank(),
  plot.background=element_blank(),
  #panel.border=element_rect(colour="#F0F0F0"),
  # Format the grid
  panel.grid.major=element_line(colour="#D0D0D0",size=.75),
  axis.ticks=element_blank())

mapTheme <- theme(plot.title =element_text(size=12),
                  plot.subtitle = element_text(size=8),
                  plot.caption = element_text(size = 6),
                  axis.line=element_blank(),
                  axis.text.x=element_blank(),
                  axis.text.y=element_blank(),
                  axis.ticks=element_blank(),
                  axis.title.x=element_blank(),
                  axis.title.y=element_blank(),
                  panel.background=element_blank(),
                  panel.border=element_blank(),
                  panel.grid.major=element_line(colour = 'transparent'),
                  panel.grid.minor=element_blank(),
                  legend.direction = "vertical", 
                  legend.position = "right",
                  plot.margin = margin(1, 1, 1, 1, 'cm'),
                  legend.key.height = unit(1, "cm"), legend.key.width = unit(0.2, "cm"))

palette2 <- c("#41b6c4","#253494")
palette4 <- c("#a1dab4","#41b6c4","#2c7fb8","#253494")
palette5 <- c("#ffffcc","#a1dab4","#41b6c4","#2c7fb8","#253494")
palette10 <- c("#f7fcf0","#e0f3db","#ccebc5","#a8ddb5","#7bccc4",
               "#4eb3d3","#2b8cbe","#0868ac","#084081","#f7fcf0")
```

```{r, warning = FALSE, message = FALSE}
#this function converts a column in to quintiles. It is used for mapping.
quintileBreaks <- function(df,variable) {
    as.character(quantile(df[[variable]],
                          c(.01,.2,.4,.6,.8),na.rm=T))
}

#This function can be used to convert a polygon sf to centroids xy coords.
xyC <- function(aPolygonSF) {
  as.data.frame(
    cbind(x=st_coordinates(st_centroid(aPolygonSF))[,1],
          y=st_coordinates(st_centroid(aPolygonSF))[,2]))
} 

#this function convert a raster to a data frame so it can be plotted in ggplot
rast <- function(inRaster) {
  data.frame(
    xyFromCell(inRaster, 1:ncell(inRaster)), 
    value = getValues(inRaster)) }
```

# Data Wrangling & Feature Engineering

##  Fishnet

Our first step is to create a fishnet, which will act as our predictive surface. Each cell will hold values for our dependent and independent variables.

```{r fishnet_plot, warning = FALSE, message= FALSE}

#austinMSA is the extent of the study area (Austing Metropolitan Statistical Area)
studyAreaCounties<- c("Williamson", "Travis","Bastrop", "Caldwell", "Hays")

austinMSA <- 
  st_read('~/GitHub/Urban_Growth_ATX/Austin_Data/Austin_MSA.geojson')%>%
  st_transform('ESRI:102741')%>%
  filter(name %in%studyAreaCounties)%>%
  st_union()

austinMSA_fishnet <- 
  st_make_grid(st_sf(austinMSA), 4000) %>%
  st_sf()

austinMSA_fishnet <-
  austinMSA_fishnet[austinMSA,]

# st_write(austinMSA_fishnet, "austinMSA_fishnet.shp")

ggplot() +
  geom_sf(data=austinMSA_fishnet) +
  labs(title="Fishnet, 4000 Foot Resolution") +
  mapTheme
```

##  Land Cover 

Our land cover data for Austin MSA is extracted from Google Earth Engine for the years 2009 - 2019. 

```{r load_2019_lc, warning = FALSE, message = FALSE}

#2009 and 2019 Land Cover data is read in

lc_2009 <- raster("~/GitHub/Urban_Growth_ATX/Austin_Data/LC_08_rast.tif")

lc_2019 <- raster("~/GitHub/Urban_Growth_ATX/Austin_Data/LC_19_rast.tif")

ggplot() +
  geom_sf(data=austinMSA) +
  geom_raster(data = rbind(rast(lc_2009) %>% mutate(label = "2009"),
                           rast(lc_2019) %>% mutate(label = "2019")) %>% 
              na.omit %>% filter(value > 0), 
              aes(x,y,fill=as.factor(value))) +
  facet_wrap(~label) +
  scale_fill_viridis(discrete=TRUE, name ="") +
  labs(title = "Land Cover, 2009 & 2019") +
  mapTheme + theme(legend.position = "none")
```

##  Dependent Variable - Land Cover Change

Our goal of this analysis is to predict new urban development, therefore the dependent variable of our regression model is going to be the positive development change seen between the years 2009 and 2019. We pre processed our land cover data in ArcGIS by reclassifying developed land and calculated the difference. We then exported this raster as a binary variable. `1` = new development and `0` = no new development.  

We join this variable to our fishnet, giving each cell an observation of either `1` or `0` for new development or no new development. 

```{r plot_LC_CHANGE, warning= FALSE, message= FALSE}

#LC Change was pre processed in ArcGIS using 2008 and 2019 Land cover data 
# Raster Calculator was used to retrieve raster cells changed from undeveloped to developed between 2008 and 2019
lc_change = raster("~/GitHub/Urban_Growth_ATX/Austin_Data/urbn_grwth_08_19.tif")
# ggplot() +
#   geom_sf(data=austinMSA, fill = 'white') +
#   geom_raster(data=rast(lc_change) %>% na.omit %>% filter(value > 0), 
#               aes(x,y,fill=as.factor(value))) +
#   scale_fill_manual(values = "#ed6728", label = "Land Cover Change")+
#   labs(title = "Land Cover Change, 2009-2019", 
#        fill = "") +
#   mapTheme
```

```{r LC_fishnet_plot, warning = FALSE, message = FALSE, echo = FALSE}

#centroid of each raster cell transformed to a point
# changePoints <-
#   rasterToPoints(lc_change) %>%
#   as.data.frame() %>%
#   st_as_sf(coords = c("x", "y"), crs = st_crs(austinMSA_fishnet))

#Join takes a long time to run - for markdown, we store the output and read it back in
# fishnet_join <- 
#   aggregate(changePoints, austinMSA_fishnet, sum) 
# 
# st_write(fishnet_join, "Austin_Data/fishnet_join.shp")
fishnet_join <- st_read("~/GitHub/Urban_Growth_ATX/Austin_Data/fishnet_join.shp")

#threshold - 100 pixels or more indicate urban growth. raster resolution is much smaller than fishnet cell size
fishnet <- fishnet_join%>%
  mutate(lc_change = ifelse(u__08_1 > 100,1,0),
         lc_change = as.factor(lc_change))%>%
  dplyr::select(lc_change)

ggplot() +
  geom_sf(data=austinMSA) +
  geom_point(data=fishnet, 
             aes(x=xyC(fishnet)$x, y=xyC(fishnet)$y, colour=lc_change)) +
  scale_colour_manual(values = palette2,
                      labels=c("No Change","New Development"),
                      name = "") +
  labs(title = "Land Cover Development Change", subtitle = "As fishnet centroids") +
  mapTheme
```

##  Predictive Variables

### Land Cover 

Our next step is to join our predictive variables to our fishnet. We begin with our original land cover raster from 2009. We reclassify these according to the table below. Each land cover classification becomes a predictor for our model. 

| Old_Classification             | New_Classification                                  |
|--------------------------------|-----------------------------------------------------|
| Open Space as well as Low, Medium and High Intensity Development | Developed |
| Deciduous, Evergreen, and Mixed Forest |  Forest |
| Pasture/Hay and Cultivated Crops | Farm |
| Woody and Emergent Herbaceous Wetlands | Woodlands |
| Barren Land, Dwarf Scrub, and Grassland/Herbaceous | Other Undeveloped |
| Water | Water |

```{r LC_reclass, warning = FALSE, message = FALSE}

# fishnet<- fishnet%>%
#   mutate(LC_08_reclass = case_when(LC_08 == 21 | LC_08 == 22 |LC_08 == 23 |LC_08 == 24~ "developed", 
#                            LC_08 == 41 | LC_08 == 42 |LC_08 == 43 ~ "forest",
#                            LC_08 == 81 | LC_08 == 82 ~ "farm", 
#                            LC_08 == 90 | LC_08 == 95 ~ "wetlands", 
#                            LC_08 == 52 | LC_08 == 71 |LC_08 == 31 ~ "otherUndeveloped",
#                            LC_08 == 11 ~ "water"))

developed <- lc_2009 == 21 | lc_2009 == 22 | lc_2009 == 23 | lc_2009 == 24
forest <- lc_2009 == 41 | lc_2009 == 42 | lc_2009 == 43 
farm <- lc_2009 == 81 | lc_2009 == 82 
wetlands <- lc_2009 == 90 | lc_2009 == 95 
otherUndeveloped <- lc_2009 == 52 | lc_2009 == 71 | lc_2009 == 31 
water <- lc_2009 == 11

names(developed) <- "developed"
names(forest) <- "forest"
names(farm) <- "farm"
names(wetlands) <- "wetlands"
names(otherUndeveloped) <- "otherUndeveloped"
names(water) <- "water"

developed19 <- lc_2019 == 21 | lc_2019 == 22 | lc_2019 == 23 | lc_2019 == 24
forest19 <- lc_2019 == 41 | lc_2019 == 42 | lc_2019 == 43 
farm19 <- lc_2019 == 81 | lc_2019 == 82 
wetlands19 <- lc_2019 == 90 | lc_2019 == 95 
otherUndeveloped19 <- lc_2019 == 52 | lc_2019 == 71 | lc_2019 == 31 
water19 <- lc_2019 == 11

names(developed19) <- "developed19"
names(forest19) <- "forest19"
names(farm19) <- "farm19"
names(wetlands19) <- "wetlands19"
names(otherUndeveloped19) <- "otherUndeveloped19"
names(water19) <- "water19"
```

```{r aggrast_func, warning = FALSE, message = FALSE}
aggregateRaster <- function(inputRasterList, theFishnet) {
  #create an empty fishnet with the same dimensions as the input fishnet
  theseFishnets <- theFishnet %>% dplyr::select()
  #for each raster in the raster list
  for (i in inputRasterList) {
  #create a variable name corresponding to the ith raster
  varName <- names(i)
  #convert raster to points as an sf
    thesePoints <-
      rasterToPoints(i) %>%
      as.data.frame() %>%
      st_as_sf(coords = c("x", "y"), crs = st_crs(theFishnet)) %>%
      filter(.[[1]] == 1)
  #aggregate to the fishnet
    thisFishnet <-
      aggregate(thesePoints, theFishnet, length) %>%
      mutate(!!varName := ifelse(is.na(.[[1]]),0,1))
  #add to the larger fishnet
    theseFishnets <- cbind(theseFishnets,thisFishnet)
  }
  #output all aggregates as one large fishnet
   return(theseFishnets)
  }
```

```{r aggrast_LC vars, warning = FALSE, message = FALSE}
theRasterList <- c(developed,forest,farm,wetlands,otherUndeveloped,water)

aggregatedRasters <-
  aggregateRaster(theRasterList, austinMSA_fishnet) %>%
  dplyr::select(developed,forest,farm,wetlands,otherUndeveloped,water) %>%
  mutate_if(is.numeric,as.factor)

aggregatedRasters %>%
  gather(var,value,developed:water) %>%
  st_cast("POLYGON") %>%    #just to make sure no weird geometries slipped in
  mutate(X = xyC(.)$x,
         Y = xyC(.)$y) %>%
  ggplot() +
    geom_sf(data=austinMSA) +
    geom_point(aes(X,Y, colour=as.factor(value))) +
    facet_wrap(~var) +
    scale_colour_manual(values = palette2,
                        labels=c("Other","Land Cover"),
                        name = "") +
    labs(title = "Land Cover Types, 2009",
         subtitle = "As fishnet centroids") +
   mapTheme
```

### Population

Population growth within an area is a huge indicator of whether that area can expect new development. We load in population data from the US Census at the tract level for 2009 and 2019. 

```{r load_census, warning = FALSE, message = FALSE, results = "hide"}

census_api_key('d5e25f48aa48bf3f0766baab06d59402ea032067')

vars <- load_variables(year = 2009,
                      dataset = "acs5",
                      cache = TRUE)

AustinPop_09 <- 
  get_acs(geography = "tract", variables = "B01003_001", year = 2009,
                state = 48, geometry = TRUE, 
                county=c("Williamson", "Travis","Bastrop", "Caldwell", "Hays")) %>%
  dplyr::select( -NAME, -moe) %>%
  spread(variable, estimate)%>% 
  rename(pop_2009 = B01003_001) %>%
  st_transform(st_crs(austinMSA_fishnet))

AustinPop_19 <- 
  get_acs(geography = "tract", variables = "B01003_001", year = 2019,
                state = 48, geometry = TRUE, 
                county=c("Williamson", "Travis","Bastrop", "Caldwell", "Hays")) %>%
  dplyr::select( -NAME, -moe) %>%
  spread(variable, estimate)%>% 
  rename(pop_2019 = B01003_001) %>%
  st_transform(st_crs(austinMSA_fishnet))

```

```{r pop_plot, warning = FALSE, message = FALSE, fig.height= 8, fig.width= 11}
grid.arrange(
ggplot() +
  geom_sf(data = AustinPop_09, aes(fill=factor(ntile(pop_2009,5))), colour=NA) +
  scale_fill_manual(values = palette5,
                    labels=quintileBreaks(AustinPop_09,"pop_2009"),
                   name="Quintile\nBreaks") +
  labs(title="Population, Houston MSA: 2009") +
  mapTheme,

ggplot() +
  geom_sf(data = AustinPop_19, aes(fill=factor(ntile(pop_2019,5))), colour=NA) +
  scale_fill_manual(values = palette5,
                    labels=quintileBreaks(AustinPop_19,"pop_2019"),
                   name="Quintile\nBreaks") +
  labs(title="Population, Houston MSA: 2019") +
  mapTheme, ncol=2)
```

```{r pop_net, warning = FALSE, message = FALSE}
austinMSA_fishnet <-
  austinMSA_fishnet %>%
  rownames_to_column("fishnetID") %>% 
  mutate(fishnetID = as.numeric(fishnetID)) %>%
  dplyr::select(fishnetID)

fishnetPopulation09 <-
  st_interpolate_aw(AustinPop_09["pop_2009"], austinMSA_fishnet, extensive=TRUE) %>%
  as.data.frame(.) %>%
  rownames_to_column(var = "fishnetID") %>%
  left_join(austinMSA_fishnet %>%
              mutate(fishnetID = as.character(fishnetID)),
            ., by=c("fishnetID"='fishnetID')) %>% 
  mutate(pop_2009 = replace_na(pop_2009,0)) %>%
  dplyr::select(pop_2009)

fishnetPopulation19 <-
  st_interpolate_aw(AustinPop_19["pop_2019"],austinMSA_fishnet, extensive=TRUE) %>%
  as.data.frame(.) %>%
  rownames_to_column(var = "fishnetID") %>%
  left_join(austinMSA_fishnet %>%
              mutate(fishnetID = as.character(fishnetID)),
            ., by=c("fishnetID"='fishnetID')) %>% 
  mutate(pop_2019 = replace_na(pop_2019,0)) %>%
  dplyr::select(pop_2019)

fishnetPopulation <- 
  cbind(fishnetPopulation09,fishnetPopulation19) %>%
  dplyr::select(pop_2009,pop_2019) %>%
  mutate(pop_Change = pop_2019 - pop_2009)
```

We join both population counts to our fishnet surface. This join is done by an area weighted calculation to appropriately allocate a population count to each fishnet cell depending on the proportion of the tract in which it falls. We then calculate the difference in population between our study years to create a population change variable that will be used in our final model. Below, we see the population change between 2009 and 2019 for each fishnet cell.

```{r pop_change_plot, warning = FALSE, message = FALSE, fig.height = 8, fig.width= 11}

ggplot() +
  geom_sf(data=fishnetPopulation, aes(fill=factor(ntile(pop_Change,5))),colour=NA) +
  scale_fill_manual(values = palette5,
                   labels=substr(quintileBreaks(fishnetPopulation,"pop_2019"),1,4),
                   name="Quintile\nBreaks") +
  labs(title="Population Change , Austin MSA: 2009 - 2019",
       subtitle="Represented as fishnet gridcells; Boundaries omitted") +
  mapTheme

```

### Highway Infrastructure

We can reasonable assume that location of major transportation infrastructure will have predictive power in new development. We load in a Texas highway shapefile from [Data.Gov](https://catalog.data.gov/dataset/tiger-line-shapefile-2019-state-texas-primary-and-secondary-roads-state-based-shapefile?msclkid=1f2c2445cfcb11ecbd34d7c3bfd332df) and clip it with our Austin MSA boundary. Because we are interested in proximity to highways, we run an euclidean distance analysis on our shapefile and join the output values to our fishnet. Below, we plot the highway shapefile and visualize it in relation to our dependent variable, land cover change. Next to it, we plot the euclidean distance values in quintile breaks. 

```{r read_highways, warning = FALSE, message = FALSE, results = "hide"}
austinHighways <-
  st_read("~/GitHub/Urban_Growth_ATX/Austin_Data/Austin_Highways.geojson") %>%
  st_transform(st_crs(austinMSA)) %>%
  st_intersection(austinMSA)
```

```{r plot_highway, warning = FALSE, message= FALSE}

```

```{r euclid, warning = FALSE, message = FALSE}

emptyRaster <- lc_change
emptyRaster[] <- NA

library(stringr)
# st_distance to highways
fishnet <- fishnet %>%
  mutate(uniqueID = as.character(row_number()))

fishnet_centroid <- fishnet %>%
  st_centroid()

highway_dist <- fishnet_centroid %>%
  st_distance(austinHighways %>%
                st_transform(st_crs(fishnet_centroid))) %>%
  as.data.frame() %>%
  mutate(uniqueID = as.character(row_number())) %>%
  gather(-uniqueID, key = "variable", value = "value") %>%
  dplyr::select(-variable) %>%
  group_by(uniqueID) %>%
 summarize(highway_dist = min(value))

highway_dist[c('num', 'str')] <- str_split_fixed(highway_dist$highway_dist, ' ', 2)
highway_dist <-highway_dist%>%
  mutate(highway_dist = as.numeric(num))%>%
  dplyr::select(uniqueID, highway_dist)


fishnet <- left_join(fishnet, highway_dist)
grid.arrange(
ggplot() +
  geom_point(data=fishnet, 
             aes(x=xyC(fishnet)[,1], y=xyC(fishnet)[,2],colour=lc_change),size=1.5) +
  geom_sf(data=austinHighways, color = 'red') +
  scale_colour_manual(values = palette2,
                      labels=c("No Change","New \nDevelopment")) +
  labs(title = "New Development and Highways",
       subtitle = "As fishnet centroids") +
  mapTheme,
ggplot() +
  geom_sf(data=austinMSA) +
  geom_point(data=fishnet, aes(x=xyC(fishnet)[,1], 
                                             y=xyC(fishnet)[,2], 
                 colour=factor(ntile(highway_dist,5))),size=1.5) +
  scale_colour_manual(values = palette5,
                      # labels=quintileBreaks(fishnet,"distance_highways"),
                      name="Quintile\nBreaks") +
  geom_sf(data=austinHighways, colour = "red") +
  labs(title = "Distance to Highways",
       subtitle = "As fishnet centroids; Highways visualized in red") +
  mapTheme, nrow = 1, widths=c(2.3,2))
```

### The Spatial Lag of Development

Our next predictive variable is the relationship of each fishnet cell to the closest observed development. We do this by creating a "spatial lag" using a nearest neighbor function. 

```{r, warning = FALSE, message = FALSE}
nn_function <- function(measureFrom,measureTo,k) {
  #convert the sf layers to matrices
  measureFrom_Matrix <-
    as.matrix(measureFrom)
  measureTo_Matrix <-
    as.matrix(measureTo)
  nn <-   
    get.knnx(measureTo, measureFrom, k)$nn.dist
    output <-
    as.data.frame(nn) %>%
    rownames_to_column(var = "thisPoint") %>%
    gather(points, point_distance, V1:ncol(.)) %>%
    arrange(as.numeric(thisPoint)) %>%
    group_by(thisPoint) %>%
    summarize(pointDistance = mean(point_distance)) %>%
    arrange(as.numeric(thisPoint)) %>% 
    dplyr::select(-thisPoint) %>%
    pull()
  
  return(output)  
}
```

```{r, warning = FALSE, message = FALSE}
fishnet$lagDevelopment <-
    nn_function(xyC(fishnet),
                xyC(filter(aggregatedRasters,developed==1)),
                2)

ggplot() +
  geom_sf(data=austinMSA) +
  geom_point(data=fishnet, 
             aes(x=xyC(fishnet)[,1], y=xyC(fishnet)[,2], 
                 colour=factor(ntile(lagDevelopment,5))), size=1.5) +
  scale_colour_manual(values = palette5,
                     labels=substr(quintileBreaks(fishnet,"lagDevelopment"),1,7),
                     name="Quintile\nBreaks") +
  labs(title = "Spatial Lag to 2009 Development",
       subtitle = "As fishnet centroids") +
  mapTheme
```

### Counties in MSA 

We also can assume that municipal boundaries will impact how much land will develop given varying legislation.We create a categorical variable that labels each fishnet cell with the county under which it exists. We see this plotted below. 

```{r, warning = FALSE, message = FALSE, results = "hide"}
options(tigris_class = "sf")

studyAreaCounties <- 
  counties("Texas") %>%
  st_transform(st_crs(austinMSA)) %>%
  dplyr::select(NAME) %>%
  .[st_buffer(austinMSA,-4000), , op=st_intersects]%>%
  filter(NAME != "Burnet" & NAME != "Guadalupe")
```

```{r, warning = FALSE, message = FALSE}
ggplot() +
  geom_sf(data = austinMSA, fill = 'white', color = 'NA')+
  geom_sf(data = fishnet, fill = NA, color = "light grey")+
  geom_sf(data=studyAreaCounties, fill = NA, size= 1) +
  labs(title = "Study Area Counties", subtitle = "With Fishnet") +
  mapTheme
```

```{r, warning = FALSE, message = FALSE}
dat <- 
  cbind(
    fishnet, fishnetPopulation, aggregatedRasters) %>%
  dplyr::select(lc_change, developed, forest, farm, wetlands, otherUndeveloped, water,
                pop_2009, pop_2019, pop_Change, highway_dist,lagDevelopment) %>%
  st_join(studyAreaCounties) %>%
  mutate(developed20 = ifelse(lc_change == 1 & developed == 1, 0, 1)) %>%
  filter(water == 0) %>%na.omit()
```

# Exploratory Analysis

Once our independent variables are joined with our fishnet into one data frame, we can begin to explore how they each relate to our dependent variable. First we explore our continuous variables: `highway_dist` and `lagDevelopment`. These plots tell us that fishnet cells that experience no new development change are associated with farther distances from highways and other development. This confirms our assumption and we can expect these variables to have reasonable predictive power. 

```{r, warning = FALSE, message = FALSE}
dat %>%
  dplyr::select(highway_dist,lagDevelopment,lc_change) %>%
  gather(Variable, Value, -lc_change, -geometry) %>%
  ggplot(., aes(lc_change, Value, fill=lc_change)) + 
    geom_bar(position = "dodge", stat = "summary", fun.y = "mean") +
    facet_wrap(~Variable) +
    scale_fill_manual(values = palette2,
                      labels=c("No Change","New Development"),
                      name="") +
    labs(title="New Development as a Function of the Continuous Variables") +
    plotTheme 
```

Next we plot our factor variables: `pop_2009`, `pop_2019` and `pop_Change`. We can see that new development occurred within the fishnet cells with the highest population in 2009 and 2019, and where population change the most between the two years. 

```{r, warning = FALSE, message = FALSE}
dat %>%
  dplyr::select(pop_2009,pop_2019,pop_Change,lc_change) %>%
  gather(Variable, Value, -lc_change, -geometry) %>%
  ggplot(., aes(lc_change, Value, fill=lc_change)) + 
    geom_bar(position = "dodge", stat = "summary", fun.y = "mean") +
    facet_wrap(~Variable) +
    scale_fill_manual(values = palette2,
                      labels=c("No Change","New Development"),
                      name="") +
    labs(title="New Development as a Function of Factor Variables") +
    plotTheme
```
Lastly, we examine the conversion rate of our land cover types to understand which undeveloped land saw the highest amount of development. Other undeveloped land which was classified from Barren Land, Dwarf Scrub and Grassland, saw the highest development at a conversion rate of almost 5% between 2009 and 2019.

```{r, warning = FALSE, message = FALSE}
dat %>%
  dplyr::select(lc_change:otherUndeveloped,developed) %>%
  gather(Land_Cover_Type, Value, -lc_change, -geometry) %>%
   st_set_geometry(NULL) %>%
     group_by(lc_change, Land_Cover_Type) %>%
     summarize(n = sum(as.numeric(Value))) %>%
     ungroup() %>%
    mutate(Conversion_Rate = paste0(round(100 * n/sum(n), 2), "%")) %>%
    filter(lc_change == 1) %>%
  dplyr::select(Land_Cover_Type,Conversion_Rate) %>%
  kable() %>% kable_styling(full_width = F)
```

# Building the Model

Finally, we begin the process of building a model to predict new development. We iterate 6 different logistic regression models using variations of variable combinations, and compare their R- squared statistic to decide which iteration has the best predictions. Model6 uses `wetlands` `forest` `farm` `oherUndeveloped` `lagDevelopment` `pop_Change` and `highway_dist` and results in an R- squared of .3. 

```{r, warning = FALSE, message = FALSE}
set.seed(3456)
trainIndex <- 
  createDataPartition(dat$developed, p = .50,
                                  list = FALSE,
                                  times = 1)
datTrain <- dat[ trainIndex,]
datTest  <- dat[-trainIndex,]

```

```{r, warning = FALSE, message = FALSE, echo = FALSE, results = 'hide'}
Model1 <- glm(lc_change ~ wetlands + forest  + farm + otherUndeveloped, 
              family="binomial"(link="logit"), data = datTrain)

Model2 <- glm(lc_change ~ wetlands + forest  + farm + otherUndeveloped + lagDevelopment, 
              family="binomial"(link="logit"), data = datTrain)
              
Model3 <- glm(lc_change ~ wetlands + forest  + farm + otherUndeveloped + lagDevelopment + pop_2009, 
              family="binomial"(link="logit"), data = datTrain)          
              
Model4 <- glm(lc_change ~ wetlands + forest  + farm + otherUndeveloped + lagDevelopment + pop_2009 + 
              pop_2019, 
              family="binomial"(link="logit"), data = datTrain)              
            
Model5 <- glm(lc_change ~ wetlands + forest  + farm + otherUndeveloped + lagDevelopment + pop_Change, 
              family="binomial"(link="logit"), data = datTrain)              
              
Model6 <- glm(lc_change ~ wetlands + forest  + farm + otherUndeveloped + lagDevelopment + pop_Change + 
              highway_dist, 
              family="binomial"(link="logit"), data = datTrain) 
```

```{r, warning = FALSE, message = FALSE, echo = FALSE}
modelList <- paste0("Model", 1:6)
map_dfc(modelList, function(x)pR2(get(x)))[4,] %>%
  setNames(paste0("Model",1:6)) %>%
  gather(Model,McFadden) %>%
  ggplot(aes(Model,McFadden)) +
    geom_bar(stat="identity") +
    labs(title= "McFadden R-Squared by Model") +
    plotTheme
```


The distribution of our predicted probabilities, plotted below, tells us that our model is excellent at predicting no change in land use, which logically makes sense given the high proportion of no development change in our dependent variable. This visual will help us determine our threshold to judge the goodness of our model via confusion matrix. 

```{r, warning = FALSE, message = FALSE}
testSetProbs <- 
  data.frame(class = datTest$lc_change,
             probs = predict(Model6, datTest, type="response")) 
  
ggplot(testSetProbs, aes(probs)) +
  geom_density(aes(fill=class), alpha=0.5) +
  scale_fill_manual(values = palette2,
                    labels=c("No Change","New Development")) +
  labs(title = "Histogram of test set predicted probabilities",
       x="Predicted Probabilities",y="Density") +
  plotTheme
```

### Accuracy

Sensitivity is the True Positive Rate. This is amount of fishnet cells that our model correctly predicted new development to occur. Specificity is the True Negative rate. Conversely, this is the amount of fishnet cells that our model correctly predicted no development to occur. Our errors are False Positive, or the amount of fishnet cells that our model incorrectly predicted development to occur, and False Negative, or the amount of fishnet cells that our model incorrectly predicted no development to occur. The implications of False Negative are that the City was unprepared for development in this area because they were not accounted for by the model. We are okay with False Positive, because the worst case scenario is over-planning.  
  
The plot below visualizes where our new development predictions occur based on a 17% threshold and a 5% threshold. We are looking for a higher Specificity in order to reduce our False Negative count. We optimize our model for our purposes by choosing the 17% threshold as a way to classify our predictions. This means that any fishnet cell with a predicted probability of higher than 17% will be classified as "New Development" and any cell below will be "no change".

```{r, warning = FALSE, message = FALSE}
options(yardstick.event_first = FALSE)

testSetProbs <- 
  testSetProbs %>% 
  mutate(predClass_05 = as.factor(ifelse(testSetProbs$probs >= 0.05 ,1,0)),
         predClass_17 = as.factor(ifelse(testSetProbs$probs >= 0.17 ,1,0))) 

testSetProbs %>%
  dplyr::select(-probs) %>%
  gather(Variable, Value, -class) %>%
  group_by(Variable) %>%
  summarize(Sensitivity = round(yardstick::sens_vec(class,factor(Value)),2),
            Specificity = round(yardstick::spec_vec(class,factor(Value)),2),
            Accuracy = round(yardstick::accuracy_vec(class,factor(Value)),2)) %>%
  kable() %>%
  kable_styling(full_width = F)
```

```{r, warning = FALSE, message = FALSE}
predsForMap <-         
  dat %>%
    mutate(probs = predict(Model6, dat, type="response") ,
           Threshold_5_Pct = as.factor(ifelse(probs >= 0.05 ,1,0)),
           Threshold_17_Pct =  as.factor(ifelse(probs >= 0.17 ,1,0))) %>%
    dplyr::select(lc_change,Threshold_5_Pct,Threshold_17_Pct) %>%
    gather(Variable,Value, -geometry) %>%
    st_cast("POLYGON")
```

```{r, warning = FALSE, message= FALSE, fig.width = 10, fig.height = 4}
ggplot() +
  geom_point(data=predsForMap, aes(x=xyC(predsForMap)[,1], y=xyC(predsForMap)[,2], colour=Value)) +
  facet_wrap(~Variable) +
  scale_colour_manual(values = palette2, labels=c("No Change","New Development"),
                      name="") +
  labs(title="Development Predictions - Low Threshold") + 
  mapTheme
```

```{r, warning = FALSE, message = FALSE}
ConfusionMatrix.metrics <-
  dat %>%
    mutate(probs = predict(Model6, dat, type="response") ,
           Threshold_5_Pct = as.factor(ifelse(probs >= 0.05 ,1,0)),
           Threshold_17_Pct =  as.factor(ifelse(probs >= 0.17 ,1,0))) %>%
    mutate(TrueP_05 = ifelse(lc_change  == 1 & Threshold_5_Pct == 1, 1,0),
           TrueN_05 = ifelse(lc_change  == 0 & Threshold_5_Pct == 0, 1,0),
           TrueP_17 = ifelse(lc_change  == 1 & Threshold_17_Pct == 1, 1,0),
           TrueN_17 = ifelse(lc_change  == 0 & Threshold_17_Pct == 0, 1,0)) %>%
    dplyr::select(., starts_with("True")) %>%
    gather(Variable, Value, -geometry) %>%
    st_cast("POLYGON") 
```

```{r, warning = FALSE, message = FALSE, fig.height= 8, fig.width= 8 }
# ggplot(data=ConfusionMatrix.metrics) +
#   geom_point(aes(x=xyC(ConfusionMatrix.metrics)[,1], 
#                  y=xyC(ConfusionMatrix.metrics)[,2], colour = as.factor(Value))) +
#   facet_wrap(~Variable) +
#   scale_colour_manual(values = palette2, labels=c("Correct","Incorrect"),
#                        name="") +
#   labs(title="Development Predictions - Sensitivity & Specificity") + mapTheme
```

### Generalizability

It is important that we check how our model generalizes across space. Our next step is to analyze how our model performs across the counties that lie within Austin MSA. Having set our 17% threshold, we output our confusion matrix statistics for each county. The Counties with higher the development change, like Williamson County, Sensitivity rates (True Positives) are comparable with the results from the test set results on the entire study area.

```{r, warning = FALSE, message = FALSE}
spatialCV <- function(dataFrame, uniqueID, dependentVariable, modelName) {

#initialize a data frame 
endList <- list()

#create a list that is all the spatial group unqiue ids in the data frame (ie counties)    
  uniqueID_List <- unique(dataFrame[[uniqueID]])  
  x <- 1
  y <- length(uniqueID_List)
  
#create a counter and while it is less than the number of counties...  
  while(x <= y) 
  {
#call a current county    
    currentUniqueID <- uniqueID_List[x]
#create a training set comprised of units not in that county and a test set of units
#that are that county
    training <- dataFrame[ which(dataFrame[[uniqueID]] != uniqueID_List[x]),]
    testing <- dataFrame[ which(dataFrame[[uniqueID]] == uniqueID_List[x]),]
#create seperate xy vectors
    trainingX <- training[ , -which(names(training) %in% c(dependentVariable))]
    testingX <- testing[ , -which(names(testing) %in% c(dependentVariable))]
    
    trainY <- training[[dependentVariable]]
    testY <- testing[[dependentVariable]]
#Calculate predictions on the test county as part of a data frame including the observed
#outcome and the unique county ID    
   thisPrediction <- 
     data.frame(class = testY,
                probs = predict(modelName, testingX, type="response"),
                county = currentUniqueID) 

#Row bind the predictions to a data farme
   endList <- rbind(endList, thisPrediction)
#iterate counter    
    x <- x + 1 
  } 
#return the final list of counties and associated predictions  
  return (as.data.frame(endList))
}
```

```{r, warning = FALSE, message = FALSE}
spatialCV_counties <-
  spatialCV(dat,"NAME","lc_change", Model6) %>%
  mutate(predClass = as.factor(ifelse(probs >= 0.17 ,1,0)))
```

```{r, warning = FALSE, message = FALSE}
spatialCV_metrics <-
  spatialCV_counties %>% 
    group_by(county) %>% 
    summarize(Observed_Change = sum(as.numeric(as.character(class))),
              Sensitivity = round(yardstick::sens_vec(class,predClass),2),
              Specificity = round(yardstick::spec_vec(class,predClass),2),
              Accuracy = round(yardstick::accuracy_vec(class,predClass),2)) 

spatialCV_metrics %>%
  kable() %>%
  kable_styling(full_width = F)
```

# Planning Scenarios

Finally, we have a model that will allow us to predict future development in Austin, Texas. Below, we present two scenarios of Demand and Supply for which we forecast. 

### Predicting for 2029 - Demand-side change

The projected population growth of the Metropolitan Statistical Area of Austin Texas between 2019 and 2029 is 700,000. To predict for 2029, we apply this population growth proportionally across the counties within the MSA. The proportions are designated by the counts of observed change within each county, discussed in the generalizability section above. The results are such that Bastrop sees a 3% increase, Caldwell 4%, Hays 14%, Williamson 38% and Travis 41%. The plot below visualizes what this change looks like across counties.

```{r, warning = FALSE, message = FALSE}

# change lagDevelopment variable to average distance to 2019 development
# keep the field name so the model will run 
dat <-
  dat %>%
  mutate(lagDevelopment = nn_function(xyC(.), xyC(filter(.,developed20 == 1)),2))
```

```{r, warning = FALSE, message = FALSE}

# update population change variable to reflect the projected change in population per fishnet cell between 2019 and 2029
# estimated Austin MSA population growth between 2019 and 2029 is 700,000
# 2019 population by each county
# Williamson County	- 570,437 : prop - 26% : growth = 182000
# Travis County	- 1,250,884 : prop - 58% : growth = 406000
# Bastrop County -	86,839 : prop - 4% : growth = 28000
# Caldwell County -	42,817 : prop - 2% : growth = 14000
# Hays County -	222,827 : prop - 10% : growth = 70000
# total: 2173804

# 2019 population by each county
# Williamson County	- 320 : prop - 38% : growth + 266000 = 836437
# Travis County	- 336 : prop - 41% : growth + 287000 = 1537884
# Bastrop County -	26 : prop - 3% : growth + 21000 = 107839
# Caldwell County -	32 : prop - 4% : growth + 28000 = 70817
# Hays County -	125 : prop - 14% : growth + 98000 = 320827
# total: 839

countyPopulation_2029 <- 
  data.frame(NAME = c("Williamson", "Travis","Bastrop", "Caldwell", "Hays"),
   county_projection_2029 = c(836437,1537884,107839,70817,320827)) %>%
   left_join( dat %>%
       st_set_geometry(NULL) %>%
       group_by(NAME) %>%
       summarize(county_population_2019 = round(sum(pop_2019))))

countyPopulation_2029 %>%
  gather(Variable,Value, -NAME) %>%
  ggplot(aes(reorder(NAME,-Value),Value)) +
  geom_bar(aes(fill=Variable), stat = "identity", position = "dodge") +
  scale_fill_manual(values = palette2,
                    labels=c("2019","2029"),
                    name="Population") +
  labs(title="Population Change by County: 2019 - 2029",
       x="County", y="Population") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  plotTheme
```

When we apply this population change to our data, and run a prediction with our model, we get the resulting predicted probabilities for development demand in 2029. The plot on the right sets a 17% threshold to our predicted probabilities, and we can say this is where we can reasonably expect new development, and where planners should allocate resources. 

```{r, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 10}
dat_infill <-
  dat %>%
  #calculate population change
    left_join(countyPopulation_2029) %>%
    mutate(proportion_of_county_pop = pop_2019 / county_population_2019,
           pop_2029.infill = proportion_of_county_pop * county_projection_2029,
           pop_Change = round(pop_2029.infill - pop_2019),2) %>%
    dplyr::select(-county_projection_2029, -county_population_2019, 
                  -proportion_of_county_pop, -pop_2029.infill) %>%
  #predict for 2020
    mutate(predict_2029.infill = predict(Model6,. , type="response"))%>%
  mutate(pop_prediction = ifelse(predict_2029.infill > .17, 1, 0))

# The map of predicted probabilities that results is best thought of as a measure of predicted development demand in 2029.
grid.arrange(
dat_infill %>%
  ggplot() +  
  geom_point(aes(x=xyC(dat_infill)[,1], y=xyC(dat_infill)[,2], colour = factor(ntile(predict_2029.infill,5)))) +
  scale_colour_manual(values = palette5,
                    labels=substr(quintileBreaks(dat_infill,"predict_2029.infill"),1,4),
                    name="Quintile\nBreaks") +
  geom_sf(data=studyAreaCounties, fill=NA, colour="black", size=1) +
  labs(title= "2029: Demand-side Scenario: \nPopulation Increase", subtitle = "Predicted Probabilities") +
  mapTheme+theme(legend.position ="bottom",
                 legend.direction = "horizontal",
                 legend.background = element_rect(fill='grey95', color = NA)),

dat_infill %>%
  ggplot() +  
  geom_point(aes(x=xyC(dat_infill)[,1], y=xyC(dat_infill)[,2], colour = factor(pop_prediction))) +
  scale_colour_manual(values = palette2,
                     labels= c("No change", "New Development"),
                    name="") +
  geom_sf(data=studyAreaCounties, fill=NA, colour="black", size=1) +
  labs(title="2029: Demand-side Scenario: \nPopulation Increase", subtitle = "17% Threshold") +
  mapTheme+theme(legend.position ="bottom",
                 legend.direction = "horizontal",
                 legend.background = element_rect(fill='grey95', color = NA)), nrow = 1, widths = c(2,2.2))
```

### Predicting for 2029 - Supply-side change

A new industrial area is developed in the center of Williamson County. This development brings dozens of new employers. How will this affect our predictions for 10 years in the future? 

```{r newdev, warning = FALSE, message = FALSE, results = 'hide'}

new_dev <- raster("~/GitHub/Urban_Growth_ATX/Austin_Data/new_dev.tif")

new_dev_shp <- 
  st_read('~/GitHub/Urban_Growth_ATX/Austin_Data/New_dev.geojson')%>%
  st_transform('ESRI:102741')

new_dev2 <- raster("~/GitHub/Urban_Growth_ATX/Austin_Data/new_dev2.tif")%>%
  mask(., austinMSA_fishnet)

# ggplot() +
#   geom_sf(data=austinMSA) +
#   geom_raster(data=rast(new_dev2) %>% na.omit,
#               # %>% filter(value > 0),
#               aes(x,y,fill=as.factor(value))) +
#   geom_sf(data = new_dev_shp, fill= NA, aes(color = "red"), size = 1)+
#   scale_color_manual(values = "red",
#                      labels = "Proposed New Development")+
#   scale_fill_manual(values = palette2, 
#                     labels = c("Not Developed", "Developed"),name ="") +
#   labs(title = "New Development Scenario, 2029") +
#   mapTheme
```

```{r  newdev2, warning = FALSE, message = FALSE}

#join new development scenario to fishnet
developed_29 <- new_dev2 == 1

names(developed_29) <- "developed_29"

developed_29_rast <-
  aggregateRaster(c(developed_29), austinMSA_fishnet) %>%
  dplyr::select(developed_29)%>%
  mutate_if(is.numeric,as.factor)

# developed_29_rast %>%
#   gather(var,value,developed_29) %>%
#   st_cast("POLYGON") %>%    #just to make sure no weird geometries slipped in
#   mutate(X = xyC(.)$x,
#          Y = xyC(.)$y) %>%
#   ggplot() +
#     geom_sf(data=austinMSA) +
#     geom_point(aes(X,Y, colour=as.factor(value))) +
#   geom_sf(data = new_dev_shp, fill= NA, color = "red", size = 1)+
#     facet_wrap(~var) +
#     scale_colour_manual(values = palette2,
#                         labels=c("Not Developed","Developed"),
#                         name = "") +
#     labs(title = "Proposed New Development, 2019",
#          subtitle = "As fishnet centroids") +
#    mapTheme

```

```{r rast1, warning = FALSE, message = FALSE}

#update variables to be 2019 baseline - developed29 is our proposed new development 
theRasterList19 <- c(developed_29,forest19,farm19,wetlands19,otherUndeveloped19,water19)

dat2 <-
  aggregateRaster(theRasterList19, dat) %>%
  dplyr::select(developed_29,forest19,farm19,wetlands19,otherUndeveloped19,water19) %>%
  st_set_geometry(NULL) %>%
  bind_cols(.,dat) %>%
  st_sf() %>%
  st_cast("POLYGON")

# dat2 %>%
#   gather(var,value,developed_29:water19) %>%
#   st_centroid() %>%
#   mutate(X = st_coordinates(.)[,1],
#          Y = st_coordinates(.)[,2]) %>%
#   ggplot() +
#     geom_sf(data=austinMSA) +
#     geom_point(aes(X,Y, colour=as.factor(value))) +
#     facet_wrap(~var) +
#     scale_colour_manual(values = palette2,
#                         labels=c("Other","Land Cover"),
#                         name = "") +
#     labs(title = "Land Cover Types, 2019",
#          subtitle = "As fishnet centroids") +
#    mapTheme
```

The industrial development is planned to fall on land classified as `otherUndeveloped` because, as we saw from our exploratory analysis, this land cover has the highest conversion rate. Williamson County has the second highest development change between 2009 and 2019, and the most available land. Below we plot the impact of this new development on our `developed` and `lagDevelopment` variables. 

```{r newdev3, warning = FALSE, message = FALSE, fig.width = 10, fig.height = 6}

#update lagDevelopment to reflect lag from new_dev
dat2 <-
  dat2 %>%
  mutate(lagDevelopment = nn_function(xyC(.), xyC(filter(.,developed_29 == 1)),2))

grid.arrange(
ggplot() +
  geom_sf(data=austinMSA) +
  geom_raster(data=rast(new_dev2) %>% na.omit,
              # %>% filter(value > 0),
              aes(x,y,fill=as.factor(value))) +
  geom_sf(data = new_dev_shp, fill= NA, aes(color = "red"), size = 1)+
  scale_color_manual(values = "red",
                     labels = "Proposed New Development")+
  scale_fill_manual(values = palette2, 
                    labels = c("Not Developed", "Developed"),name ="") +
  labs(title = "Proposed New Development") +
  mapTheme+theme(legend.position = "bottom",
                 legend.direction = "horizontal"),


ggplot() +
  geom_sf(data=austinMSA) +
  geom_point(data=dat2, 
             aes(x=xyC(dat2)[,1], y=xyC(dat2)[,2], 
                 colour=factor(ntile(lagDevelopment,5))), size=1.5) +
  scale_colour_manual(values = palette5,
                     labels=substr(quintileBreaks(dat2,"lagDevelopment"),1,7),
                     name="Quintile\nBreaks") +
  labs(title = "Spatial Lag to Proposed New Development",
       subtitle = "As fishnet centroids") +
  mapTheme+theme(legend.position = "bottom",
                 legend.direction = "horizontal"), nrow = 1)
```

When we apply this new development to our data, and run a prediction with our model, we get the resulting predicted probabilities for development demand in 2029 from supply-side change. The plot on the right sets a 17% threshold to our predicted probabilities, and we can say this is where we can reasonably expect new development, and where planners should allocate resources, given our new development plan. 

```{r dat2, warning = FALSE, message = FALSE}

dat2 <-
  dat2 %>%
    mutate(predict_2029.dev = predict(Model6,. , type="response"))%>%
  mutate(predProbs = ifelse(predict_2029.dev > .17, 1, 0))


grid.arrange(
dat2 %>%
  ggplot() +  
  geom_point(aes(x=xyC(dat2)[,1], y=xyC(dat2)[,2], colour = factor(ntile(predict_2029.dev,5)))) +
  scale_colour_manual(values = palette5,
                    labels=substr(quintileBreaks(dat2,"predict_2029.dev"),1,4),
                    name="Quintile\nBreaks") +
  geom_sf(data=studyAreaCounties, fill=NA, colour="black", size=1) +
  labs(title= "2029: Supply Side Scenario: \nNew Development", subtitle = "Predicted Probabilities") +
  mapTheme+theme(legend.position ="bottom",
                 legend.direction = "horizontal",
                 legend.background = element_rect(fill='grey95', color = NA)),
dat2 %>%
  ggplot() +  
  geom_point(aes(x=xyC(dat2)[,1], y=xyC(dat2)[,2], colour = factor(predProbs))) +
  scale_colour_manual(values = palette2,
                     labels= c("No change", "New Development"),
                    name=" ") +
  geom_sf(data=studyAreaCounties, fill=NA, colour="black", size=1) +
  labs(title= "2029: Supply Side Scenario: \nNew Development", subtitle = "17% Threshold") +
  mapTheme+theme(legend.position ="bottom",
                 legend.direction = "horizontal",
                 legend.background = element_rect(fill='grey95', color = NA)), nrow = 1)
# 
# dat2 %>%
#   ggplot() +  
#   geom_point(aes(x=xyC(dat2)[,1], y=xyC(dat2)[,2], colour = as.factor(predProbs))) +
#   scale_colour_manual(values = palette2) +
#   geom_sf(data=studyAreaCounties, fill=NA, colour="black", size=1) +
#   labs(title= "Supply Side Scenario: \nNew Development") +
#   mapTheme+theme(legend.position ="bottom",
#                  legend.direction = "horizontal",
#                  legend.background = element_rect(fill='grey95', color = NA))
```

# Conclusion

### Planning Allocation

For officials in Williamson County trying to manage the development demand for 2029 associated with the new industrial development, we highlight feasible development opportunities. First, we rule out development over sensitive land cover regions which are classified from wetlands and forest land cover. The plot below uses existing development and sensitive regions as a mask over our predicted probabilities of development within Williamson County. Dark blue fishnet cells are most likely to develop by 2029 and should be accounted for by Williamson planners and officials. 

```{r, warning = FALSE, message = FALSE, fig.height = 6, fig.width= 6}
dat2 <-
  dat2 %>%
   mutate(sensitive_lost19 = ifelse(forest == 1 & forest19 == 0 |
                                    wetlands == 1 & wetlands19 == 0,1,0))
                      
# ggplot() +
#   geom_point(data=dat2, aes(x=xyC(dat2)[,1], y=xyC(dat2)[,2], colour=as.factor(sensitive_lost19))) +
#   scale_colour_manual(values = palette2,
#                       labels=c("No Change","Sensitive Lost"),
#                       name = "") +
#   labs(title = "Sensitive lands lost: 2009 - 2019",
#        subtitle = "As fishnet centroids") +
#   mapTheme
```

```{r, warning = FALSE, message = FALSE, fig.height = 6, fig.width= 6}
sensitiveRegions <- 
  raster::clump(wetlands19 + forest19) %>%
  rasterToPolygons() %>%
  st_as_sf() %>%
  group_by(clumps) %>% 
  summarize() %>%
    mutate(Acres = as.numeric(st_area(.) * 0.0000229568)) %>%
    filter(Acres > 3954)  %>%
  dplyr::select() %>%
  raster::rasterize(.,emptyRaster) 
sensitiveRegions[sensitiveRegions > 0] <- 1  
names(sensitiveRegions) <- "sensitiveRegions"

dat2 <-
  aggregateRaster(c(sensitiveRegions), dat2) %>%
  dplyr::select(sensitiveRegions) %>%
  st_set_geometry(NULL) %>%
  bind_cols(.,dat2) %>%
  st_sf()

# ggplot() +
#   geom_point(data=dat2, aes(x=xyC(dat2)[,1], y=xyC(dat2)[,2], colour=as.factor(sensitiveRegions))) +
#   scale_colour_manual(values = palette2,
#                       labels=c("Other","Sensitive Regions"),
#                       name="") +
#   labs(title = "Sensitive regions",
#        subtitle = "Continous areas of either wetlands or forests\ngreater than 1 acre") +
#   mapTheme
```

```{r, warning = FALSE, message = FALSE}
county_specific_metrics <- 
  dat2 %>%
  #predict development demand from our model
  mutate(Development_Demand = predict(Model6, dat2, type="response")) %>%
  #get a count count of grid cells by county which we can use to calculate rates below
  left_join(st_set_geometry(dat, NULL) %>% group_by(NAME) %>% summarize(count = n())) %>%
  #calculate summary statistics by county
  group_by(NAME) %>%
  summarize(Total_Farmland = sum(farm19) / max(count),
            Total_Forest = sum(forest19) / max(count),
            Total_Wetlands = sum(wetlands19) / max(count),
            Total_Undeveloped = sum(otherUndeveloped19) / max(count),
            Mean_Development_Demand = mean(Development_Demand)) %>%
  #get population data by county
  left_join(countyPopulation_2029 %>% 
            mutate(Population_Change = county_projection_2029 - county_population_2019,
                   Population_Change_Rate = Population_Change / county_projection_2029) %>%
            dplyr::select(NAME,Population_Change_Rate))
```

```{r, warning = FALSE, message = FALSE}
# county_specific_metrics %>%
#   gather(Variable, Value, -NAME, -geometry) %>%
#   mutate(Variable = factor(Variable, levels=c("Population_Change_Rate","Mean_Development_Demand",
#                                               "Total_Farmland","Total_Undeveloped","Total_Forest",
#                                               "Total_Wetlands","Sensitive_Land_Lost","Sensitive_Regions",
#                                               ordered = TRUE))) %>%
#   mutate(Planning_Designation = case_when(
#     Variable == "Population_Change_Rate" | Variable == "Mean_Development_Demand" ~ "Demand-Side",
#     Variable == "Total_Farmland" | Variable == "Total_Undeveloped"               ~ "Suitable",
#     TRUE                                                                         ~ "Not Suitable")) %>%
#   ggplot(aes(x=Variable, y=Value, fill=Planning_Designation)) +
#     geom_bar(stat="identity", position=position_dodge(), colour="black") +
#     facet_wrap(~NAME, ncol=5) +
#     coord_flip() +
#     scale_y_continuous(breaks = seq(.25, 1, by = .25)) +
#     geom_vline(xintercept = 2.5) + geom_vline(xintercept = 4.5) +
#     scale_fill_manual(values=c("black","red","darkgreen")) +
#     labs(title= "County Specific Allocation Metrics", subtitle= "As rates", x="Indicator", y="Rate") +
#     plotTheme + theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position="bottom")
```

```{r, warning = FALSE, message = FALSE, fig.height= 8, fig.width= 11}

Williamson <-
  dat2 %>%
    mutate(Development_Demand = predict(Model6, dat2, type="response")) %>%
    filter(NAME == "Williamson") 

Williamson_landUse <- rbind(
  filter(Williamson, forest19 == 1 | wetlands19 == 1 ) %>%
  dplyr::select() %>% mutate(Land_Use = "Not Suitable"),
  filter(Williamson, developed_29 == 1) %>%
  dplyr::select() %>% mutate(Land_Use = "Developed"))


grid.arrange(
ggplot() +
  geom_sf(data=Williamson, aes(fill=factor(ntile(Development_Demand,5))), colour=NA) +
  # geom_sf(data = austinMSA, color = "black", fill = NA)+
  geom_point(data=Williamson_landUse, aes(x=xyC(Williamson_landUse)[,1], 
                                        y=xyC(Williamson_landUse)[,2], colour=Land_Use),
                                        shape = 15, size = 1.5) +
geom_sf(data=st_intersection(austinHighways,filter(studyAreaCounties, NAME=="Williamson")), size=1, color = "white") +  scale_fill_manual(values = palette5, name="Development\nDemand",
                    labels=substr(quintileBreaks(Williamson,"Development_Demand"),1,5)) +
  scale_colour_manual(values = c("black","grey85")) + 
  labs(title = "Development Potential, 2029: Williamson") + mapTheme +
  guides(fill = guide_legend(order = 1), colour = guide_legend(order = 2)),

ggplot() +
  geom_sf(data=Williamson, aes(fill=factor(ntile(pop_Change,5))), colour=NA) +
  # geom_sf(data = austinMSA, color = "black", fill = NA)+
  geom_point(data=Williamson_landUse, aes(x=xyC(Williamson_landUse)[,1], 
                                        y=xyC(Williamson_landUse)[,2], colour=Land_Use),
                                        shape = 15, size = 1.5) +
geom_sf(data=st_intersection(austinHighways,filter(studyAreaCounties, NAME=="Williamson")), size=1, color = "white") +   scale_fill_manual(values = palette5, name="Population\nChange",
                    labels=substr(quintileBreaks(Williamson,"pop_Change"),1,5)) +
  scale_colour_manual(values = c("black","grey85")) + 
  labs(title = "Projected Population, 2029: Williamson") + mapTheme +
  guides(fill = guide_legend(order = 1), colour = guide_legend(order = 2)), ncol=2)
```
